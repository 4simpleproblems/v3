<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4SP | AI Assistant</title>
    <link rel="stylesheet" href="styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="firebase-config.js"></script>

    <style>
        :root {
            --dark-bg: #1a1a1a;
            --darker-bg: #0d0d0d;
            --light-text: #f0f0f0;
            --light-gray: #e0e0e0;
            --accent-color: #6366f1;
            --accent-hover: #4f46e5;
        }

        body {
            background-color: var(--light-gray);
            color: var(--dark-bg);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            font-family: 'Roboto Mono', monospace;
        }

        main.container {
            max-width: 1000px;
            margin: 2rem auto;
            padding: 0 2rem;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        footer {
            text-align: center;
            padding: 1rem 0;
            color: #333333;
        }

        /* Navigation bar styling */
        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 3rem;
            background-color: var(--darker-bg);
            color: var(--light-text);
            border-bottom: 1px solid var(--darker-bg);
        }
        .logo {
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: -1.5px;
        }
        .nav-buttons {
            display: flex;
            gap: 1.5rem;
            align-items: center;
        }

        /* Button styles */
        .btn {
            display: inline-block;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-size: 1rem;
            line-height: normal;
            cursor: pointer;
            text-align: center;
            border: 2px solid transparent;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .btn.secondary {
            background-color: transparent;
            color: var(--light-text);
            border-color: var(--light-text);
        }
        .btn.primary {
            background-color: var(--accent-color);
            color: white;
            border: none;
        }
        .btn.primary:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
        }
        .btn.danger {
            background-color: #ef4444;
            color: white;
        }
        .btn.danger:hover {
            background-color: #dc2626;
        }

        .hidden {
            display: none !important;
        }

        /* Page title */
        .page-title {
            font-size: 2.2rem;
            margin: 1.5rem 0;
            font-weight: 700;
        }

        /* Chat container */
        .chat-container {
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 6px 12px rgba(0,0,0,0.08);
            height: 70vh;
            margin-bottom: 1rem;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .message {
            max-width: 80%;
            padding: 1rem 1.5rem;
            border-radius: 18px;
            line-height: 1.5;
            animation: fadeIn 0.3s ease;
            word-wrap: break-word;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            align-self: flex-end;
            background-color: var(--accent-color);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .ai-message {
            align-self: flex-start;
            background-color: #f0f0f0;
            color: var(--dark-bg);
            border-bottom-left-radius: 4px;
        }

        .timestamp {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 5px;
            text-align: right;
        }

        .chat-input-container {
            display: flex;
            padding: 1rem;
            background-color: #f9f9f9;
            border-top: 1px solid #e0e0e0;
        }

        .chat-input {
            flex: 1;
            padding: 1rem 1.5rem;
            border: 2px solid #e0e0e0;
            border-radius: 50px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1rem;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .chat-input:focus {
            border-color: var(--accent-color);
        }

        .send-button {
            margin-left: 0.5rem;
        }

        /* AI model selector and controls */
        .chat-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .model-selector {
            display: flex;
            gap: 0.5rem;
        }

        .model-option {
            padding: 0.5rem 1.5rem;
            border: 2px solid #e0e0e0;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .model-option.selected {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .chat-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Loading indicator */
        .typing-indicator {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            background-color: #f0f0f0;
            border-radius: 18px;
            width: fit-content;
            margin-left: 1rem;
        }

        .typing-dot {
            height: 8px;
            width: 8px;
            border-radius: 50%;
            background-color: #555;
            margin: 0 2px;
            animation: typingAnimation 1.5s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.5s; }
        .typing-dot:nth-child(3) { animation-delay: 1s; }

        @keyframes typingAnimation {
            0% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }

        /* Status message */
        .status-message {
            text-align: center;
            padding: 0.5rem;
            font-size: 0.8rem;
            color: #666;
            font-style: italic;
        }

        /* Custom API Key modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 24px;
            width: 90%;
            max-width: 500px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .close-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-body input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            margin-bottom: 1rem;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="logo">4SP</div>
        <div class="nav-buttons">
            <a href="dashboard.html" class="btn secondary">Back to Dashboard</a>
            <a href="#" class="btn secondary" id="logoutBtn">Log Out</a>
        </div>
    </nav>

    <main class="container">
        <h1 class="page-title">AI Assistant</h1>
        <div class="hidden" id="authNotice">Please login to access the AI assistant</div>

        <div id="aiInterface" class="hidden">
            <div class="chat-controls">
                <div class="model-selector">
                    <div class="model-option selected" data-model="gpt">GPT-3.5</div>
                    <div class="model-option" data-model="gpt4">GPT-4</div>
                    <div class="model-option" data-model="claude">Claude</div>
                    <div class="model-option" data-model="custom" id="customModelBtn">Custom API</div>
                </div>
                <div class="chat-actions">
                    <button class="btn secondary" id="clearChatBtn">Clear Chat</button>
                </div>
            </div>

            <div class="chat-container">
                <div class="chat-messages" id="chatMessages">
                    <!-- Messages will be loaded dynamically -->
                </div>
                
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="userInput" placeholder="Type your message..." />
                    <button class="btn primary send-button" id="sendButton">Send</button>
                </div>
            </div>
            <div class="status-message" id="statusMessage"></div>
        </div>
    </main>

    <!-- Custom API Key Modal -->
    <div class="modal hidden" id="apiKeyModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Custom API Configuration</h2>
                <button class="close-button" id="closeModalBtn">&times;</button>
            </div>
            <div class="modal-body">
                <p>Enter your API key for the selected model:</p>
                <input type="password" id="apiKeyInput" placeholder="API Key" />
                <p>Enter the API endpoint (optional):</p>
                <input type="text" id="endpointInput" placeholder="https://api.example.com/v1/completions" />
            </div>
            <div class="modal-footer">
                <button class="btn secondary" id="cancelModalBtn">Cancel</button>
                <button class="btn primary" id="saveApiKeyBtn">Save</button>
            </div>
        </div>
    </div>

    <footer>
        <p>Â© 2025 4SP</p>
    </footer>

    <script>
        // Global variables
        let currentUser = null;
        let db = null;
        let selectedModel = 'gpt';
        let customApiConfig = {
            key: '',
            endpoint: ''
        };

        // Initialize Firebase
        function initFirebase() {
            try {
                // Initialize Firestore
                db = firebase.firestore();
                console.log("Firebase initialized successfully");
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showStatus("Error initializing Firebase. Some features may not work.", true);
            }
        }

        // Authentication state management
        function handleAuthState(user) {
            const authNotice = document.getElementById('authNotice');
            const aiInterface = document.getElementById('aiInterface');
            const logoutBtn = document.getElementById('logoutBtn');

            if (user) {
                currentUser = user;
                authNotice.classList.add('hidden');
                aiInterface.classList.remove('hidden');
                if (logoutBtn) logoutBtn.classList.remove('hidden');
                
                // Load chat history for the current model
                loadChatHistory();
                
                // Add welcome message if no chat history
                setTimeout(() => {
                    const chatMessages = document.getElementById('chatMessages');
                    if (chatMessages.children.length === 0) {
                        addInitialWelcomeMessage();
                    }
                }, 500);
            } else {
                window.location.href = 'index.html';
            }
        }

        // Initialize Firebase authentication and set up logout functionality
        function initAuth() {
            try {
                const auth = firebase.auth();

                const logoutBtn = document.getElementById('logoutBtn');
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', (e) => {
                        e.preventDefault(); // Prevent any default link behavior
                        auth.signOut().then(() => {
                            window.location.href = 'index.html';
                        }).catch(error => {
                            console.error("Logout error:", error);
                        });
                    });
                }

                auth.onAuthStateChanged(user => {
                    handleAuthState(user);
                });

            } catch (error) {
                console.error("Auth initialization error:", error);
                const notice = document.getElementById('authNotice');
                if (notice) {
                    notice.textContent = 'Error loading application components. Please try again later.';
                    notice.classList.remove('hidden');
                }
            }
        }

        // Status message functions
        function showStatus(message, isError = false) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? '#ef4444' : '#666';
            
            // Clear after 5 seconds
            setTimeout(() => {
                statusMessage.textContent = '';
            }, 5000);
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            const date = timestamp instanceof Date ? timestamp : timestamp.toDate();
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) + 
                   ' ' + date.toLocaleDateString();
        }

        // Add initial welcome message
        function addInitialWelcomeMessage() {
            const welcomeMessage = {
                text: "Hello! I'm your AI assistant. How can I help you today?",
                sender: "ai",
                timestamp: new Date()
            };
            
            // Save to Firestore and display
            saveMessageToFirestore(welcomeMessage)
                .then(() => {
                    displayMessage(welcomeMessage);
                })
                .catch(error => {
                    console.error("Error saving welcome message:", error);
                    displayMessage(welcomeMessage); // Display anyway even if save fails
                });
        }

        // AI Chat functionality
        function initAIChat() {
            const chatMessages = document.getElementById('chatMessages');
            const userInput = document.getElementById('userInput');
            const sendButton = document.getElementById('sendButton');
            const modelOptions = document.querySelectorAll('.model-option');
            const clearChatBtn = document.getElementById('clearChatBtn');
            const customModelBtn = document.getElementById('customModelBtn');
            
            let isWaitingForResponse = false;

            // Model selection
            modelOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const previousModel = selectedModel;
                    selectedModel = option.getAttribute('data-model');
                    
                    if (previousModel !== selectedModel) {
                        modelOptions.forEach(opt => opt.classList.remove('selected'));
                        option.classList.add('selected');
                        
                        // Load chat history for the newly selected model
                        loadChatHistory();
                    }

                    // Show API key modal for custom model
                    if (selectedModel === 'custom') {
                        document.getElementById('apiKeyModal').classList.remove('hidden');
                    }
                });
            });

            // Clear chat button
            clearChatBtn.addEventListener('click', () => {
                if (confirm("Are you sure you want to clear all messages for this AI model?")) {
                    clearChatHistory();
                }
            });

            // Custom API modal functionality
            const apiKeyModal = document.getElementById('apiKeyModal');
            const closeModalBtn = document.getElementById('closeModalBtn');
            const cancelModalBtn = document.getElementById('cancelModalBtn');
            const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
            const apiKeyInput = document.getElementById('apiKeyInput');
            const endpointInput = document.getElementById('endpointInput');

            // Close modal functions
            function closeModal() {
                apiKeyModal.classList.add('hidden');
                // If no API key is set and trying to use custom, switch back to GPT
                if (selectedModel === 'custom' && !customApiConfig.key) {
                    selectedModel = 'gpt';
                    modelOptions.forEach(opt => {
                        opt.classList.remove('selected');
                        if (opt.getAttribute('data-model') === 'gpt') {
                            opt.classList.add('selected');
                        }
                    });
                    loadChatHistory();
                }
            }

            closeModalBtn.addEventListener('click', closeModal);
            cancelModalBtn.addEventListener('click', closeModal);
            
            // Save API key
            saveApiKeyBtn.addEventListener('click', () => {
                const apiKey = apiKeyInput.value.trim();
                const endpoint = endpointInput.value.trim();
                
                if (apiKey) {
                    customApiConfig.key = apiKey;
                    customApiConfig.endpoint = endpoint || '';
                    apiKeyModal.classList.add('hidden');
                    showStatus("Custom API configuration saved");
                    loadChatHistory(); // Reload chat for custom model
                } else {
                    alert("Please enter a valid API key");
                }
            });

            // Function to display a message in the chat
            function displayMessage(message) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message');
                messageElement.classList.add(message.sender === 'user' ? 'user-message' : 'ai-message');
                
                // Message text
                messageElement.textContent = message.text;
                
                // Add timestamp
                const timestampElement = document.createElement('div');
                timestampElement.classList.add('timestamp');
                timestampElement.textContent = formatTimestamp(message.timestamp);
                messageElement.appendChild(timestampElement);
                
                chatMessages.appendChild(messageElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Function to show typing indicator
            function showTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.classList.add('typing-indicator');
                indicator.id = 'typingIndicator';
                
                for (let i = 0; i < 3; i++) {
                    const dot = document.createElement('div');
                    dot.classList.add('typing-dot');
                    indicator.appendChild(dot);
                }
                
                chatMessages.appendChild(indicator);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            // Function to hide typing indicator
            function hideTypingIndicator() {
                const indicator = document.getElementById('typingIndicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            // Function to get AI response from different providers
            async function getAIResponse(userMessage) {
                // This is where you would integrate with real AI APIs
                // For now, we'll use mock responses based on the selected model
                
                // Model-specific responses
                const responses = {
                    gpt: [
                        "I'm GPT-3.5 and I can assist with general questions and tasks.",
                        "As GPT-3.5, I can help you find information about various topics.",
                        "GPT-3.5 here! I can help with creative content, information, and more."
                    ],
                    gpt4: [
                        "GPT-4 at your service. I have enhanced reasoning capabilities.",
                        "As GPT-4, I can tackle more complex problems with better reasoning.",
                        "This is GPT-4. I'm designed to handle nuanced requests with greater accuracy."
                    ],
                    claude: [
                        "Claude here! I'm designed to be helpful, harmless, and honest.",
                        "As Claude, I prioritize safe and thoughtful responses.",
                        "Claude AI ready to assist with your questions in a thoughtful manner."
                    ],
                    custom: [
                        "Custom AI model response. This would connect to your configured API.",
                        "Your custom AI is processing your request with your specific settings.",
                        "Using your custom API configuration to generate this response."
                    ]
                };

                // Simple keyword response mapping for better demo experience
                if (userMessage.toLowerCase().includes('help')) {
                    return `I can help you find sounds, suggest games, or answer questions about 4SP. What would you like to know about specifically?`;
                } else if (userMessage.toLowerCase().includes('sound') || userMessage.toLowerCase().includes('music')) {
                    return `The 4SP sound library includes memes, music clips, and sound effects. Would you like me to suggest some popular categories?`;
                } else if (userMessage.toLowerCase().includes('game')) {
                    return `Check out the games section! What kind of games do you enjoy? Arcade classics, puzzles, or multiplayer games?`;
                } else if (userMessage.toLowerCase().includes('proxy')) {
                    return `The proxy section provides tools to access content. You have options like Interstellar and US4 available.`;
                }

                // Get random response based on model
                const modelResponses = responses[selectedModel] || responses.gpt;
                return modelResponses[Math.floor(Math.random() * modelResponses.length)];
            }

            // Save message to Firestore
            async function saveMessageToFirestore(message) {
                if (!currentUser || !db) return Promise.reject("User not authenticated or DB not available");
                
                try {
                    const userDocRef = db.collection('users').doc(currentUser.uid);
                    const chatCollectionRef = userDocRef
                        .collection('chats')
                        .doc(selectedModel)
                        .collection('messages');
                    
                    // Add the message with a server timestamp
                    await chatCollectionRef.add({
                        text: message.text,
                        sender: message.sender,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    return Promise.resolve();
                } catch (error) {
                    console.error("Error saving message:", error);
                    return Promise.reject(error);
                }
            }

            // Function to handle sending a message
            async function sendMessage() {
                if (isWaitingForResponse || !userInput.value.trim()) return;
                
                const userMessage = userInput.value.trim();
                userInput.value = '';
                
                // Create message object
                const message = {
                    text: userMessage,
                    sender: 'user',
                    timestamp: new Date()
                };
                
                // Save and display user message
                try {
                    await saveMessageToFirestore(message);
                    displayMessage(message);
                } catch (error) {
                    console.error("Error saving user message:", error);
                    displayMessage(message); // Still display even if save fails
                }
                
                // Show AI is typing
                isWaitingForResponse = true;
                showTypingIndicator();
                
                try {
                    // Get AI response (would be an API call in production)
                    const aiResponseText = await getAIResponse(userMessage);
                    
                    // Create AI message object
                    const aiMessage = {
                        text: aiResponseText,
                        sender: 'ai',
                        timestamp: new Date()
                    };
                    
                    // Save and display AI message
                    await saveMessageToFirestore(aiMessage);
                    hideTypingIndicator();
                    displayMessage(aiMessage);
                } catch (error) {
                    console.error("Error with AI response:", error);
                    hideTypingIndicator();
                    
                    // Display error message if AI response fails
                    const errorMessage = {
                        text: "Sorry, I encountered an error. Please try again later.",
                        sender: 'ai',
                        timestamp: new Date()
                    };
                    displayMessage(errorMessage);
                    showStatus("Failed to get AI response. Please try again.", true);
                } finally {
                    isWaitingForResponse = false;
                }
            }

            // Load chat history from Firestore
            window.loadChatHistory = function() {
                if (!currentUser || !db) {
                    showStatus("Cannot load chat history. Please try refreshing the page.", true);
                    return;
                }
                
                // Clear current messages
                chatMessages.innerHTML = '';
                showStatus("Loading chat history...");
                
                // Get messages for current user and selected model
                db.collection('users').doc(currentUser.uid)
                    .collection('chats')
                    .doc(selectedModel)
                    .collection('messages')
                    .orderBy('timestamp', 'asc')
                    .get()
                    .then((querySnapshot) => {
                        if (querySnapshot.empty) {
                            addInitialWelcomeMessage();
                            showStatus("Started a new conversation");
                        } else {
                            querySnapshot.forEach((doc) => {
                                const messageData = doc.data();
                                displayMessage({
                                    text: messageData.text,
                                    sender: messageData.sender,
                                    timestamp: messageData.timestamp
                                });
                            });
                            showStatus("Chat history loaded");
                        }
                    })
                    .catch((error) => {
                        console.error("Error loading chat history:", error);
                        showStatus("Failed to load chat history", true);
                    });
            };

            // Clear chat history
            window.clearChatHistory = function() {
                if (!currentUser || !db) {
                    showStatus("Cannot clear chat history. Please try refreshing the page.", true);
                    return;
                }
                
                // Clear UI
                chatMessages.innerHTML = '';
                showStatus("Clearing chat history...");
                
                // Delete collection is complex in Firestore
                // For simplicity, we'll just add a new document indicating the chat was cleared
                db.collection('users').doc(currentUser.uid)
                    .collection('chats')
                    .doc(selectedModel)
                    .set({
                        clearedAt: firebase.firestore.FieldValue.serverTimestamp()
                    })
                    .then(() => {
                        // Delete messages subcollection (limited to batches in client-side code)
                        deleteCollection(
                            db,
                            `users/${currentUser.uid}/chats/${selectedModel}/messages`,
                            20
                        ).then(() => {
                            addInitialWelcomeMessage();
                            showStatus("Chat history cleared");
                        });
                    })
                    .catch((error) => {
                        console.error("Error clearing chat:", error);
                        showStatus("Failed to clear chat history", true);
                    });
            };

            // Helper function to delete a collection in batches
            async function deleteCollection(db, collectionPath, batchSize) {
                const collectionRef = db.collection(collectionPath);
                const query = collectionRef.orderBy('__name__').limit(batchSize);

                return new Promise((resolve, reject) => {
                    deleteQueryBatch(db, query, resolve).catch(reject);
                });
            }

            async function deleteQueryBatch(db, query, resolve) {
                const snapshot = await query.get();

                const batchSize = snapshot.size;
                if (batchSize === 0) {
                    // When there are no documents left, we are done
                    resolve();
                    return;
                }

                // Delete documents in a batch
                const batch = db.batch();
                snapshot.docs.forEach((doc) => {
                    batch.delete(doc.ref);
                });

                await batch.commit();

                // Recurse on the next process tick, to avoid
                // exploding the stack.
                process.nextTick(() => {
                    deleteQueryBatch(db, query, resolve);
                });
            }

            // Event listeners
            sendButton.addEventListener('click', sendMessage);
            
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        }

        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof firebase !== 'undefined') {
                initFirebase();
                initAuth();
                initAIChat();
            } else {
                console.error("Firebase SDK not loaded.");
                document.getElementById('authNotice').textContent = 'Error loading application components. Please try again later.';
                document.getElementById('authNotice').classList.remove('hidden');
            }
        });
    </script>
</body>
</html>
